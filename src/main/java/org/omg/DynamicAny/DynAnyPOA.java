package org.omg.DynamicAny;


/**
* org/omg/DynamicAny/DynAnyPOA.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from /Users/russgold/projects/glassfish/glassfish-corba/target/checkout/omgapi/src/main/idl/DynamicAny.idl
* Friday, July 14, 2017 11:15:15 AM EDT
*/


/**
    * Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.
    * A DynAny object is associated with a data value which corresponds to a copy of the value
    * inserted into an any.
    * <P>A DynAny object may be viewed as an ordered collection of component DynAnys.
    * For DynAnys representing a basic type, such as long, or a type without components,
    * such as an empty exception, the ordered collection of components is empty.
    * Each DynAny object maintains the notion of a current position into its collection
    * of component DynAnys. The current position is identified by an index value that runs
    * from 0 to n-1, where n is the number of components.
    * The special index value -1 indicates a current position that points nowhere.
    * For values that cannot have a current position (such as an empty exception),
    * the index value is fixed at -1.
    * If a DynAny is initialized with a value that has components, the index is initialized to 0.
    * After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode
    * that permits components), the current position depends on the type of value represented by
    * the DynAny. (The current position is set to 0 or -1, depending on whether the new DynAny
    * gets default values for its components.)
    * <P>The iteration operations rewind, seek, and next can be used to change the current position
    * and the current_component operation returns the component at the current position.
    * The component_count operation returns the number of components of a DynAny.
    * Collectively, these operations enable iteration over the components of a DynAny, for example,
    * to (recursively) examine its contents.
    * <P>A constructed DynAny object is a DynAny object associated with a constructed type.
    * There is a different interface, inheriting from the DynAny interface, associated with
    * each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array,
    * exception, and value type).
    * <P>A constructed DynAny object exports operations that enable the creation of new DynAny objects,
    * each of them associated with a component of the constructed data value.
    * As an example, a DynStruct is associated with a struct value. This means that the DynStruct
    * may be seen as owning an ordered collection of components, one for each structure member.
    * The DynStruct object exports operations that enable the creation of new DynAny objects,
    * each of them associated with a member of the struct.
    * <P>If a DynAny object has been obtained from another (constructed) DynAny object,
    * such as a DynAny representing a structure member that was created from a DynStruct,
    * the member DynAny is logically contained in the DynStruct.
    * Calling an insert or get operation leaves the current position unchanged.
    * Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny)
    * also destroys any component DynAny objects obtained from it.
    * Destroying a non-top level DynAny object does nothing.
    * Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.
    * If the programmer wants to destroy a DynAny object but still wants to manipulate some component
    * of the data value associated with it, then he or she should first create a DynAny for the component
    * and, after that, make a copy of the created DynAny object.
    * <P>The behavior of DynAny objects has been defined in order to enable efficient implementations
    * in terms of allocated memory space and speed of access. DynAny objects are intended to be used
    * for traversing values extracted from anys or constructing values of anys at runtime.
    * Their use for other purposes is not recommended.
    * <P>Insert and get operations are necessary to handle basic DynAny objects
    * but are also helpful to handle constructed DynAny objects.
    * Inserting a basic data type value into a constructed DynAny object
    * implies initializing the current component of the constructed data value
    * associated with the DynAny object. For example, invoking insert_boolean on a
    * DynStruct implies inserting a boolean data value at the current position
    * of the associated struct data value.
    * A type is consistent for inserting or extracting a value if its TypeCode is equivalent to
    * the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode
    * of the DynAny at the current position.
    * <P>DynAny and DynAnyFactory objects are intended to be local to the process in which they are
    * created and used. This means that references to DynAny and DynAnyFactory objects cannot be exported
    * to other processes, or externalized with ORB.object_to_string().
    * If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.
    * Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard
    * org.omg.CORBA.Object interface. However, any attempt to invoke operations exported through the Object
    * interface may raise the standard NO_IMPLEMENT exception.
    * An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception.
    */
public abstract class DynAnyPOA extends org.omg.PortableServer.Servant
 implements org.omg.DynamicAny.DynAnyOperations, org.omg.CORBA.portable.InvokeHandler
{

  // Constructors

  private static java.util.Hashtable _methods = new java.util.Hashtable ();
  static
  {
    _methods.put ("type", new java.lang.Integer (0));
    _methods.put ("assign", new java.lang.Integer (1));
    _methods.put ("from_any", new java.lang.Integer (2));
    _methods.put ("to_any", new java.lang.Integer (3));
    _methods.put ("equal", new java.lang.Integer (4));
    _methods.put ("destroy", new java.lang.Integer (5));
    _methods.put ("copy", new java.lang.Integer (6));
    _methods.put ("insert_boolean", new java.lang.Integer (7));
    _methods.put ("insert_octet", new java.lang.Integer (8));
    _methods.put ("insert_char", new java.lang.Integer (9));
    _methods.put ("insert_short", new java.lang.Integer (10));
    _methods.put ("insert_ushort", new java.lang.Integer (11));
    _methods.put ("insert_long", new java.lang.Integer (12));
    _methods.put ("insert_ulong", new java.lang.Integer (13));
    _methods.put ("insert_float", new java.lang.Integer (14));
    _methods.put ("insert_double", new java.lang.Integer (15));
    _methods.put ("insert_string", new java.lang.Integer (16));
    _methods.put ("insert_reference", new java.lang.Integer (17));
    _methods.put ("insert_typecode", new java.lang.Integer (18));
    _methods.put ("insert_longlong", new java.lang.Integer (19));
    _methods.put ("insert_ulonglong", new java.lang.Integer (20));
    _methods.put ("insert_wchar", new java.lang.Integer (21));
    _methods.put ("insert_wstring", new java.lang.Integer (22));
    _methods.put ("insert_any", new java.lang.Integer (23));
    _methods.put ("insert_dyn_any", new java.lang.Integer (24));
    _methods.put ("insert_val", new java.lang.Integer (25));
    _methods.put ("get_boolean", new java.lang.Integer (26));
    _methods.put ("get_octet", new java.lang.Integer (27));
    _methods.put ("get_char", new java.lang.Integer (28));
    _methods.put ("get_short", new java.lang.Integer (29));
    _methods.put ("get_ushort", new java.lang.Integer (30));
    _methods.put ("get_long", new java.lang.Integer (31));
    _methods.put ("get_ulong", new java.lang.Integer (32));
    _methods.put ("get_float", new java.lang.Integer (33));
    _methods.put ("get_double", new java.lang.Integer (34));
    _methods.put ("get_string", new java.lang.Integer (35));
    _methods.put ("get_reference", new java.lang.Integer (36));
    _methods.put ("get_typecode", new java.lang.Integer (37));
    _methods.put ("get_longlong", new java.lang.Integer (38));
    _methods.put ("get_ulonglong", new java.lang.Integer (39));
    _methods.put ("get_wchar", new java.lang.Integer (40));
    _methods.put ("get_wstring", new java.lang.Integer (41));
    _methods.put ("get_any", new java.lang.Integer (42));
    _methods.put ("get_dyn_any", new java.lang.Integer (43));
    _methods.put ("get_val", new java.lang.Integer (44));
    _methods.put ("seek", new java.lang.Integer (45));
    _methods.put ("rewind", new java.lang.Integer (46));
    _methods.put ("next", new java.lang.Integer (47));
    _methods.put ("component_count", new java.lang.Integer (48));
    _methods.put ("current_component", new java.lang.Integer (49));
  }

  public org.omg.CORBA.portable.OutputStream _invoke (String $method,
                                org.omg.CORBA.portable.InputStream in,
                                org.omg.CORBA.portable.ResponseHandler $rh)
  {
    throw new org.omg.CORBA.BAD_OPERATION();
  } // _invoke

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:omg.org/DynamicAny/DynAny:1.0"};

  public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId)
  {
    return (String[])__ids.clone ();
  }

  public DynAny _this() 
  {
    return DynAnyHelper.narrow(
    super._this_object());
  }

  public DynAny _this(org.omg.CORBA.ORB orb) 
  {
    return DynAnyHelper.narrow(
    super._this_object(orb));
  }


} // class DynAnyPOA
